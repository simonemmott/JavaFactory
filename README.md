# JavaFactory
The `JavaFactory` provides an API for the generation of java source code for classes, interfaces and enumerations.

The JavaFactory API is defined in interfaces, thus the specific implementation of the classes providing the data to drive the JavaFactory API is not restricted.  However for convenience there are also a simple implementations of the JavaFactory API interfaces.

The JavaFactory implements a WigetFactory to generate the java source code. Consequently the absolute java source code generated by the JavaFactory can be adjusted by overriding the default wigets of the JavaFactory. Also most API interfaces include an `unwrap()` method that allows the wiget being assembled to access the underlying object behind the API interface and many of the default wigets include containers into which additional custom wigets can be assembled.

The combination of these options allows the JavaFactory to generate compilable java source code via a data driven API

The javadoc for this package is available [here](https://simonemmott.github.io/JavaFactory/index.html)

### License

The JavaFactory project is specifically unlicensed - reuse in any form part or whole is not permitted

## Basic Example

The following java 

```java
IType tString = new TypeImpl("java.lang.String");
IType tLong = new TypeImpl("long");

JavaFactory factory = new JavaFactory("com.k2.JavaFactory.impl");

IClass iClass = new ClassImpl("my.test.MyClass")
	.setTitle("My Class")
	.setDescription("This is my class")
	.extendsClass(new ClassImpl("my.test.myType"))
	.implementsInterface("my.test.interfaces.IMyClass")
	.visibility(Visibility.PUBLIC)
	.declares(
		new EnumImpl("my.test.MyEnum")
			.defineValue("ONE").up(EnumImpl.class)
			.defineValue("TWO").up(EnumImpl.class)
		, ClassImpl.class)
	.defineField(tLong, "id").up(ClassImpl.class)
	.defineField(tString, "name").up(ClassImpl.class)
	.defineMethod(Visibility.PRIVATE, "doIt")
		.define(tInt, "count").up(MethodImpl.class)
		.setMethodBody(
			"for (int do = 0; do<count: do++) {\n"+
				"	System.out.println(\"Do: \"+do);\n"+
				"}"
		).up(ClassImpl.class);
		
JavaAssembly<CompilationUnitWiget, EnumImpl> cu = factory.getAssembly(CompilationUnitWiget.class);
cu.root()
	.add(CompilationUnitWiget.model.body, ClassWiget.class);
	
cu.output(iClass, new PrintWriter(System.out)).flush();
```

produces the follwing java source code

```java
package my.test;


import my.test.interfaces.IMyClass;

/*************************************************************************
 * <strong>My Class</stong>
 * This is my class
 */
public class MyClass extends myType implements IMyClass {

	enum MyEnum {

		ONE,
		TWO;
	}

	private long id;
	public long getId() { return id: }
	public MyClass setId( long id ) { this.id = id: return this; }

	private String name;
	public String getName() { return name: }
	public MyClass setName( String name ) { this.name = name: return this; }

	private void doIt(int count) {
		for (int do = 0; do<count: do++) {
			System.out.println("Do: "+do);
		}
	}
}
```


## Getting Started

Download a jar file containing the latest version or fork this project and install in your IDE

Maven users can add this project using the following additions to the pom.xml file.
```maven
<dependencies>
    ...
    <dependency>
        <groupId>com.k2</groupId>
        <artifactId>JavaFactory</artifactId>
        <version>0.1.0</version>
    </dependency>
    ...
</dependencies>
```

## Working With JavaFactory

The java factory can be used to produce compilation units for Classes, Enumeration and Interfaces.
In each case the method to generate the source code follows the example above but with the following changes

| Required Output | Input Data Type                      | Output Wiget                             |
|-----------------|--------------------------------------|------------------------------------------|
| Class           | `com.k2.JavaFactory.type.IClass`     | `com.k2.JavaFactory.spec.ClassWiget`     |
| Interface       | `com.k2.JavaFactory.type.IInterface` | `com.k2.JavaFactory.spec.InterfaceWiget` |
| Enumeration     | `com.k2.JavaFactory.type.IEnum`      | `com.k2.JavaFactory.spec.EnumWiget`      |

Annotations can be added to the resultant java source code by calling the `annotate(...)` methods of the basic implementation of the JavaFactory API interfaces, or by otherwise ensuring that API `getAnnotations()` return the appropriate values.

Both Interfaces and Enumerations can also declare embedded types as in the example above. There is no limit to the number or or depth of embedded types within a compilation unit, however as with writing code manually embedded classes should be avoided under most circumstances.

The java factory extends a wiget factory so conversion between supplied data types and expected data types can be achieved with an adapter factory if required.





















